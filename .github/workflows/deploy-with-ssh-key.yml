name: Build & Deploy to IONOS VPS (Docker)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: deploy-main
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: suryadizhang/my-portfolio-webapp

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      image: ${{ steps.image.outputs.image }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=sha,prefix=main-
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Output image
      id: image
      run: |
        echo "Generated tags: ${{ steps.meta.outputs.tags }}"
        echo "image=${{ fromJSON(steps.meta.outputs.json).tags[0] }}" >> $GITHUB_OUTPUT

  extract:
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 20
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Extract application from Docker image
      run: |
        # Debug: Show what image we're trying to pull
        echo "ğŸ” Attempting to pull image: ${{ needs.build.outputs.image }}"
        
        # Pull the built image
        docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
        
        # Check if image exists before pulling
        if ! docker pull ${{ needs.build.outputs.image }}; then
          echo "âŒ Image not found: ${{ needs.build.outputs.image }}"
          echo "ğŸ” Available images in registry:"
          docker search ghcr.io/suryadizhang/my-portfolio-webapp || true
          exit 1
        fi
        
        echo "âœ… Successfully pulled image: ${{ needs.build.outputs.image }}"
        
        # Extract the monorepo application files properly
        mkdir -p extracted
        docker run --rm -v $(pwd)/extracted:/output ${{ needs.build.outputs.image }} sh -c "
          # Copy the standalone build (already at root in container)
          cp -r /app/apps /output/ &&
          cp -r /app/node_modules /output/ || true &&
          cp /app/package.json /output/ || true &&
          # Copy the .next static files and standalone server
          mkdir -p /output/apps/web/.next &&
          cp -r /app/apps/web/.next/static /output/apps/web/.next/ || true
        "
        
        # Create a production server script that handles monorepo structure
        cat > extracted/server.js << 'EOF'
        #!/usr/bin/env node
        const path = require('path');
        const fs = require('fs');

        const hostname = process.env.HOSTNAME || 'localhost';
        const port = parseInt(process.env.PORT || '3000', 10);

        console.log('ğŸš€ Starting Next.js production server...');
        console.log(`ğŸ“ Server will run on http://${hostname}:${port}`);

        // For the Docker-extracted structure, the server is at apps/web/server.js
        const serverPath = path.join(__dirname, 'apps/web/server.js');

        if (fs.existsSync(serverPath)) {
          console.log('ğŸ¯ Using Next.js standalone server...');
          
          // Set environment variables for standalone server
          process.env.HOSTNAME = hostname;
          process.env.PORT = port.toString();
          
          // Require the standalone server
          require(serverPath);
        } else {
          console.error('âŒ Server not found at:', serverPath);
          console.log('ğŸ” Available files:');
          console.log(fs.readdirSync(__dirname));
          if (fs.existsSync(path.join(__dirname, 'apps'))) {
            console.log('Apps directory:', fs.readdirSync(path.join(__dirname, 'apps')));
            if (fs.existsSync(path.join(__dirname, 'apps/web'))) {
              console.log('Web directory:', fs.readdirSync(path.join(__dirname, 'apps/web')));
            }
          }
          process.exit(1);
        }
        EOF
        
        # Create deployment bundle
        cd extracted
        tar -czf ../deployment.tar.gz .
        
    - name: Upload deployment bundle
      uses: actions/upload-artifact@v4
      with:
        name: deployment-bundle
        path: deployment.tar.gz
        retention-days: 1

  deploy:
    runs-on: ubuntu-latest
    needs: [build, extract]
    timeout-minutes: 30
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Download deployment bundle
      uses: actions/download-artifact@v4
      with:
        name: deployment-bundle
        
    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy to VPS
      run: |
        # Upload bundle
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
          deployment.tar.gz \
          apiportfolio@${{ secrets.VPS_HOST }}:/tmp/deployment-${{ github.sha }}.tar.gz
          
        # Deploy on VPS
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no apiportfolio@${{ secrets.VPS_HOST }} "
          set -euo pipefail
          
          echo 'ğŸš€ Starting deployment...'
          
          # Create deployment directory
          mkdir -p /var/www/vhosts/apiportfolio.mysticdatanode.net/httpdocs
          cd /var/www/vhosts/apiportfolio.mysticdatanode.net/httpdocs
          
          # Backup current deployment
          if [ -d '.next' ]; then
            echo 'ğŸ“¦ Backing up current deployment...'
            mv .next .next.backup.\$(date +%s) || true
            mv public public.backup.\$(date +%s) || true
          fi
          
          # Stop existing Node.js processes
          echo 'ğŸ”„ Stopping existing processes...'
          pkill -f 'node.*server.js' || true
          pkill -f 'node.*app.js' || true
          sleep 2
          
          # Extract new deployment
          echo 'ğŸ“‚ Extracting new deployment...'
          tar -xzf /tmp/deployment-${{ github.sha }}.tar.gz
          rm /tmp/deployment-${{ github.sha }}.tar.gz
          
          # Verify the structure after extraction
          if [ -f 'apps/web/server.js' ]; then
            echo 'âœ… Docker-extracted server found at apps/web/server.js'
          elif [ -f 'server.js' ]; then
            echo 'âœ… Root server.js found'
          else
            echo 'âŒ Server not found, listing structure:'
            ls -la || true
            find . -name 'server.js' -type f || true
            exit 1
          fi
          
          # Set production environment
          export NODE_ENV=production
          export NEXT_PUBLIC_API_BASE_URL=https://apiportfolio.mysticdatanode.net/api
          export NEXT_PUBLIC_SITE_URL=https://apiportfolio.mysticdatanode.net
          export PORT=3000
          export HOSTNAME=localhost
          
          # Start the application
          echo 'ğŸ¯ Starting application...'
          nohup /usr/bin/node server.js > /tmp/portfolio.log 2>&1 & echo \$! > /tmp/portfolio.pid
          
          # Wait for startup
          sleep 5
          
          # Check if process is running
          if kill -0 \$(cat /tmp/portfolio.pid) 2>/dev/null; then
            echo 'âœ… Application started successfully with PID:' \$(cat /tmp/portfolio.pid)
            echo 'ğŸ“‹ Last few log lines:'
            tail -10 /tmp/portfolio.log
          else
            echo 'âŒ Application failed to start, showing full logs:'
            cat /tmp/portfolio.log
            exit 1
          fi
          
          echo 'ğŸ‰ Deployment completed successfully!'
        "
        
    - name: Verify Deployment
      run: |
        echo "Waiting for application to start..."
        sleep 10
        curl -f -s -o /dev/null ${{ secrets.SITE_URL }} && echo "âœ… Site is accessible!" || echo "âŒ Site check failed"