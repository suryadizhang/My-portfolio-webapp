name: "CI/CD Pipeline"

on:
  push:
    branches: [main, develop]
    paths:
      - 'apps/web/**'
      - 'packages/ui/**'
      - 'packages/utils/**'
      - 'packages/config/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'
      - '.github/workflows/**'
  pull_request:
    branches: [main, develop]
    paths:
      - 'apps/web/**'
      - 'packages/ui/**'
      - 'packages/utils/**'
      - 'packages/config/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean

concurrency:
  group: monorepo-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write
  deployments: write

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  # ---------- CHANGE DETECTION ----------
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.changes.outputs.web }}
      api: ${{ steps.changes.outputs.api }}
      python: ${{ steps.changes.outputs.python }}
      shared: ${{ steps.changes.outputs.shared }}
      infra: ${{ steps.changes.outputs.infra }}
      any: ${{ steps.changes.outputs.any }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect changed paths
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            web:
              - "apps/web/**"
              - "packages/ui/**"
              - "packages/config/**"
            api:
              - "apps/api/**"
              - "packages/utils/**"
              - "packages/config/**"
            python:
              - "apps/service-python/**"
            shared:
              - "packages/**"
              - "package.json"
              - "package-lock.json"
              - "turbo.json"
              - "tsconfig.base.json"
            infra:
              - ".github/workflows/**"
              - "Dockerfile*"
              - "docker-compose*.yml"
              - "nginx.conf"
              - "**/Dockerfile"
            any:
              - "**"

  # ---------- WEB APP (Next.js) ----------
  web-ci:
    needs: detect-changes
    if: needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.shared == 'true' || needs.detect-changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "package-lock.json"

      - name: Install dependencies
        run: npm ci --include-workspace-root --workspaces

      - name: Workspace health check
        run: |
          echo "üîç Verifying workspace packages..."
          node -e "
            try {
              require.resolve('@portfolio/ui');
              require.resolve('@portfolio/utils');
              console.log('‚úÖ All workspace packages resolved successfully');
            } catch (e) {
              console.error('‚ùå Workspace package resolution failed:', e.message);
              process.exit(1);
            }
          "

      - name: Type check
        run: npm run typecheck

      - name: Lint (non-blocking)
        run: npm run lint || echo "‚ö†Ô∏è Linting issues found (non-blocking)"

      - name: Run tests
        run: npm run test

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.OWNER }}/portfolio-web
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=pr
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        if: github.event_name != 'pull_request'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=web
          cache-to: type=gha,mode=max,scope=web
          platforms: linux/amd64

      - name: Verify standalone output
        if: github.event_name != 'pull_request'
        run: |
          # Verify server.js exists in container at /app/server.js
          echo "üîç Verifying standalone output structure..."
          docker run --rm --entrypoint="" ${{ steps.meta.outputs.tags }} \
            sh -c "test -f /app/server.js || (echo '‚ùå Standalone server.js missing at /app/server.js' && ls -la /app/ && exit 1)"
          
          # Quick smoke test - start container and verify it runs
          echo "üß™ Running container smoke test..."
          docker run --rm -d --name test-web -p 3001:3000 ${{ steps.meta.outputs.tags }}
          sleep 3
          
          if docker ps | grep -q test-web; then
            echo "‚úÖ Web container is running"
            docker stop test-web
          else
            echo "‚ùå Web container failed to start"
            docker logs test-web || true
            exit 1
          fi
          
          echo "‚úÖ Docker image verification passed"

  # ---------- PYTHON SERVICE ----------  
  python-ci:
    needs: detect-changes
    if: needs.detect-changes.outputs.python == 'true' || needs.detect-changes.outputs.infra == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: |
            apps/service-python/requirements.txt
            apps/service-python/pyproject.toml

      - name: Install Python dependencies
        working-directory: apps/service-python
        run: |
          python -m pip install --upgrade pip
          
          # Install production dependencies
          echo "üì¶ Installing production dependencies..."
          pip install -r requirements.txt
          
          # Install development dependencies - try pyproject.toml first, fallback to requirements-dev.txt
          echo "üîß Installing development dependencies..."
          if pip install -e ".[dev]" 2>/dev/null; then
            echo "‚úÖ Installed dev dependencies from pyproject.toml"
          elif [ -f requirements-dev.txt ]; then
            echo "üìã Fallback: Installing dev dependencies from requirements-dev.txt"
            pip install -r requirements-dev.txt
          else
            echo "‚ö†Ô∏è No dev dependencies configuration found"
            exit 1
          fi
          
          # Verify critical testing tools are available
          echo "üîç Verifying testing tools..."
          python -c "import pytest; import ruff; print('‚úÖ Testing tools ready')" || {
            echo "‚ùå Critical testing tools missing"
            exit 1
          }

      - name: Python code quality
        working-directory: apps/service-python
        run: |
          echo "üîç Running Python quality checks..."
          
          # Syntax check for all Python files
          find app/ -name "*.py" -exec python -m py_compile {} \;
          
          # Ruff linting (now installed via dev dependencies)
          echo "üîé Running Ruff linting..."
          ruff check app/ || echo "‚ö†Ô∏è Ruff linting issues found (non-blocking)"
          
          # Type checking if mypy is available
          if command -v mypy &> /dev/null; then
            echo "üîç Running type checking..."
            mypy app/ || echo "‚ö†Ô∏è Type checking issues found (non-blocking)"
          fi

      - name: Run Python tests
        working-directory: apps/service-python
        run: |
          if [ -d "tests" ] && find tests -name "*.py" -type f | grep -q .; then
            echo "üß™ Running Python tests..."
            python -m pytest tests/ -v --tb=short
          else
            echo "‚ÑπÔ∏è No tests found, skipping test execution"
          fi

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.OWNER }}/portfolio-python
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=pr  
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        if: github.event_name != 'pull_request'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./apps/service-python
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=python
          cache-to: type=gha,mode=max,scope=python
          platforms: linux/amd64

      - name: Smoke test Python service
        if: github.event_name != 'pull_request'
        run: |
          echo "üß™ Running Python service smoke test..."
          docker run --rm -d --name test-python -p 8001:8000 ${{ steps.meta.outputs.tags }}
          sleep 5
          
          if docker ps | grep -q test-python; then
            echo "‚úÖ Python service container is running"
            # Test basic endpoint if health check exists
            curl -f http://localhost:8001/health || echo "‚ÑπÔ∏è No health endpoint available"
            docker stop test-python
          else
            echo "‚ùå Python service failed smoke test"
            docker logs test-python || true
            exit 1
          fi

  # ---------- DEPLOYMENTS ----------
  deploy-web:
    needs: [detect-changes, web-ci]
    if: github.ref == 'refs/heads/main' && (needs.detect-changes.outputs.web == 'true' || needs.detect-changes.outputs.shared == 'true' || needs.detect-changes.outputs.infra == 'true' || github.event.inputs.force_deploy == true)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: 
      name: web-production
      url: https://apiportfolio.mysticdatanode.net

    steps:
      - name: Create deployment
        uses: actions/github-script@v7
        id: deployment
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'web-production',
              description: 'Deploy web app to production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Set deployment status (in progress)
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'in_progress',
              description: 'Deploying web app...'
            });

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.WEB_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.WEB_VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Extract application bundle
        run: |
          echo "ÔøΩ Extracting application bundle from Docker image..."
          
          # Create container and extract /app
          CID=$(docker create "${{ needs.web-ci.outputs.image }}")
          mkdir -p extracted
          docker cp "$CID:/app" extracted/
          docker rm "$CID"
          
          # Verify server.js exists
          test -f extracted/app/server.js || { echo "‚ùå /app/server.js missing"; exit 1; }
          
          # Package for deployment
          cd extracted/app
          tar -czf ../../deployment.tar.gz .
          echo "‚úÖ Application bundle created: deployment.tar.gz"

      - name: Deploy web application
        id: deploy
        run: |
          echo "üöÄ Deploying web app to production..."
          
          # Upload bundle to server
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no deployment.tar.gz \
            apiportfolio@${{ secrets.WEB_VPS_HOST }}:/tmp/deployment-${GITHUB_SHA}.tar.gz
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no apiportfolio@${{ secrets.WEB_VPS_HOST }} "
            set -euo pipefail
            
            # Zero-downtime deployment
            echo 'üîÑ Performing zero-downtime deployment...'
            
            # Stop existing process
            if [ -f /tmp/portfolio.pid ]; then
              OLD_PID=\$(cat /tmp/portfolio.pid)
              if kill -0 \$OLD_PID 2>/dev/null; then
                echo '‚èπÔ∏è Stopping existing process...'
                kill -TERM \$OLD_PID
                sleep 5
                kill -KILL \$OLD_PID 2>/dev/null || true
              fi
            fi
            
            # Deploy new version
            cd /var/www/vhosts/apiportfolio.mysticdatanode.net/httpdocs
            tar -xzf /tmp/deployment-${GITHUB_SHA}.tar.gz
            
            # Set environment variables
            export NODE_ENV=production
            export PORT=3000
            export HOSTNAME=localhost
            export NEXT_PUBLIC_API_BASE_URL=https://apiportfolio.mysticdatanode.net/api
            export NEXT_PUBLIC_SITE_URL=https://apiportfolio.mysticdatanode.net
            export OPENAI_API_KEY='${{ secrets.OPENAI_API_KEY }}'
            export WEBHOOK_SECRET='${{ secrets.WEBHOOK_SECRET }}'
            export SMTP_HOST='${{ secrets.SMTP_HOST }}'
            export SMTP_PORT='${{ secrets.SMTP_PORT }}'
            export SMTP_SECURE='${{ secrets.SMTP_SECURE }}'
            export SMTP_USER='${{ secrets.SMTP_USER }}'
            export SMTP_PASS='${{ secrets.SMTP_PASS }}'
            export FROM_EMAIL='${{ secrets.FROM_EMAIL }}'
            export TO_EMAIL='${{ secrets.TO_EMAIL }}'
            export IP_SALT='${{ secrets.IP_SALT }}'
            
            # Start new process
            echo 'üéØ Starting new web service...'
            nohup /usr/bin/node server.js > /tmp/portfolio.log 2>&1 & echo \$! > /tmp/portfolio.pid
            
            # Health check
            echo 'üîç Waiting for service to be ready...'
            for i in {1..30}; do
              if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
                echo '‚úÖ Web service is healthy'
                break
              fi
              if [ \$i -eq 30 ]; then
                echo '‚ùå Health check failed after 30 attempts'
                tail -50 /tmp/portfolio.log
                exit 1
              fi
              sleep 2
            done
            
            # Cleanup
            rm -f /tmp/deployment-${GITHUB_SHA}.tar.gz
          "

      - name: Set deployment status (success)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Web app deployed successfully',
              environment_url: 'https://apiportfolio.mysticdatanode.net'
            });

      - name: Set deployment status (failure)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Web app deployment failed'
            });

  deploy-python:
    needs: [detect-changes, python-ci]
    if: github.ref == 'refs/heads/main' && (needs.detect-changes.outputs.python == 'true' || needs.detect-changes.outputs.infra == 'true' || github.event.inputs.force_deploy == true)
    runs-on: ubuntu-latest  
    timeout-minutes: 10
    environment:
      name: python-production
      url: http://apiportfolio.mysticdatanode.net:8000

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PYTHON_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PYTHON_VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy Python service
        run: |
          echo "üöÄ Deploying Python service..."
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no apiportfolio@${{ secrets.PYTHON_VPS_HOST }} "
            set -euo pipefail
            
            # Login and pull new image
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            NEW_IMAGE='${{ needs.python-ci.outputs.image }}'
            docker pull \$NEW_IMAGE
            
            # Deploy with minimal downtime
            if docker ps | grep -q portfolio-python; then
              docker stop portfolio-python --time=10 || true
              docker rm portfolio-python || true  
            fi
            
            docker run -d \
              --name portfolio-python \
              --restart unless-stopped \
              -p 8000:8000 \
              \$NEW_IMAGE
            
            # Quick health check
            sleep 5
            if docker ps | grep -q portfolio-python; then
              echo '‚úÖ Python service deployed successfully'
            else
              echo '‚ùå Python service deployment failed'
              docker logs portfolio-python || true
              exit 1
            fi
          "

  # ---------- DEPLOYMENT SUMMARY ----------
  deployment-summary:
    needs: [detect-changes, web-ci, python-ci, deploy-web, deploy-python]
    if: always() && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Summary
        run: |
          echo "# üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Changes Detected" >> $GITHUB_STEP_SUMMARY
          echo "- **Web**: ${{ needs.detect-changes.outputs.web }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Python**: ${{ needs.detect-changes.outputs.python }}" >> $GITHUB_STEP_SUMMARY  
          echo "- **Shared**: ${{ needs.detect-changes.outputs.shared }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Infrastructure**: ${{ needs.detect-changes.outputs.infra }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Results" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-web.result }}" == "success" ]]; then
            echo "- ‚úÖ **Web App**: Deployed successfully to [production](https://apiportfolio.mysticdatanode.net)" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-web.result }}" == "skipped" ]]; then
            echo "- ‚è≠Ô∏è **Web App**: No changes, deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **Web App**: Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.deploy-python.result }}" == "success" ]]; then
            echo "- ‚úÖ **Python Service**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.deploy-python.result }}" == "skipped" ]]; then  
            echo "- ‚è≠Ô∏è **Python Service**: No changes, deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå **Python Service**: Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

  # ---------- OVERALL STATUS ----------
  ci-status:
    needs: [detect-changes, web-ci, python-ci, deploy-web, deploy-python]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Check overall status
        run: |
          echo "üîç Checking overall CI/CD status..."
          
          # Check if any required jobs failed
          FAILED_JOBS=""
          
          if [[ "${{ needs.web-ci.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS web-ci"
          fi
          
          if [[ "${{ needs.python-ci.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS python-ci"
          fi
          
          if [[ "${{ needs.deploy-web.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS deploy-web"
          fi
          
          if [[ "${{ needs.deploy-python.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS deploy-python"
          fi
          
          if [[ -n "$FAILED_JOBS" ]]; then
            echo "‚ùå The following jobs failed: $FAILED_JOBS"
            exit 1
          else
            echo "‚úÖ All jobs completed successfully or were skipped appropriately"
          fi